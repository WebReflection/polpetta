{
  "name": "stream-stack",
  "description": "Filter low-level `Stream` instances into stackable, protocol-based streams.",
  "version": "1.1.4",
  "author": {
    "name": "Nathan Rajlich",
    "email": "nathan@tootallnate.net"
  },
  "keywords": [
    "stream",
    "stack",
    "protocol",
    "filter"
  ],
  "devDependencies": {
    "expresso": "*"
  },
  "main": "./stream-stack",
  "scripts": {
    "test": "expresso"
  },
  "engines": {
    "node": ">= 0.3.0"
  },
  "directories": {},
  "dependencies": {},
  "readme": "node-stream-stack\n=================\n### Filter low-level `Stream` instances into stackable, protocol-based streams.\n\nThis module exposes the `StreamStack` interface, which starts off as a node\n`Stream` subclass that accepts a \"parent\" Stream to work with. `StreamStack` is\nmeant to be subclassed in order to implement the layers of a protocol, or run the\nparent Stream's data through some kind of filter (i.e. compression).\n\nBy default, a `StreamStack` instance proxies all events downstream (from the\nparent stream to the child stream), and proxies all functions calls upstream\n(from the child stream to the parent stream).\n\nKeeping the `StreamStack` subclass' implementation independent of the parent\n`Stream` instance allows for the backend transport to be easily swapped out\nfor flexibility and code re-use. For example, storing `netcat` results to a file,\nand using `fs.ReadStream` as your parent stream, rather than `net.Stream`, in your\ntest cases.\n\nSince `StreamStack` inherits from the regular node `Stream`, all it's prototypal\ngoodies can be used along with your subclass instances. This makes it extremely\neasy for you to call `Stream#pipe(writable)`, in order to utilize node's data\ntransfer philosophies.\n\n\nA Simple Example\n----------------\n\nHere's a simple, kinda silly example:\n\n``` js\nvar util = require('util');\nvar StreamStack = require('stream-stack').StreamStack;\n\n// The first argument is the parent stream\nfunction DoubleWrite(stream) {\n  StreamStack.call(this, stream);\n}\nutil.inherits(DoubleWrite, StreamStack);\n\n// Overwrite the default `write()` function to call\n// write() on the parent stream twice!\nDoubleWrite.prototype.write = function(data) {\n  this.stream.write(data);\n  this.stream.write(data);\n}\n\n\n// How to Use:\nvar doubleStdout = new DoubleWrite(process.stdout);\ndoubleStdout.write(\"this will be printed twice!\\n\");\n```\n\nWe've defined a `DoubleWrite` class. It accepts a writable stream, and\nwhenever `write()` is called on the DoubleWrite instance, then in return\n`write()` get called _twice_ on the parent stream. In this example, our\nwritable stream, `process.stdout`, will get the string printed to it twice.\n\n\nKnown Subclasses\n----------------\n\nCheck out the [Wiki][] page to see the list of [Known Subclasses][Wiki].\n\n[Wiki]: https://github.com/TooTallNate/node-stream-stack/wiki\n",
  "readmeFilename": "README.md",
  "_id": "stream-stack@1.1.4",
  "dist": {
    "shasum": "8b9bfd0218acf670f82ba5b83cffeb633216b8a5"
  },
  "_from": "stream-stack@>= 1.1.1",
  "_resolved": "https://registry.npmjs.org/stream-stack/-/stream-stack-1.1.4.tgz"
}
